<?php

/*
 * This file is part of the byteferry/sdds package.
 *
 * (c) ByteFerry <byteferry@qq.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Sdds\DataDiagram;

use Sdds\Constants\SelectorConstants;
use Sdds\Dispatcher\DispatcherTrait;
use Sdds\Exceptions\InvalidArgumentException;
use Sdds\Exceptions\RuntimeException;
use Sdds\Constants\NodeTypeConstants;

/**
 * Class DataNode
 * @package Sdds\DataDiagram
 */
class DataNode
{
    use DispatcherTrait;

    /**
     * @var string
     * @desc give the name part of function in the extension.
     */
    public $event_type = 'dataNode';
    /**
     * @var array
     */
    public $attributes = [
        "comment" => "",
        "position" => 0,
        "length" => 0,
        "type" => "",
        "name" => "",
        "byte_fields" => [],
        "bit_fields" => [],
        "before_change" => [],
        "after_change" => [],
        "value" => "",
        "repeat" => false,
        "until"=> null,
        "count"=> null,
        "formula" => "",
        "format" => "",
        "one_of" => [],
        "debug" => false,
        "trace" => "",
        "unsigned" => "",
        "id" => "",
        "required" => false,
        "default" => "",
        "ignore_errors" => false,
        "selector" => "",
        "list" => [],
        "key" => []
    ];

    /**
     * @var array
     * @desc A backup copy for the isset check.
     */
    private $attributes_keys;

    /**
     * @var array
     * @desc Keeping the child nodes generated by reading or writing
     */
    public $_children = [];

    /**
     * @var int
     * @desc Describe the type of the children.
     */
    public $_child_type = 0;

    /**
     * @var int
     * @desc The level of the node in the tree
     */
    public $_level = 0;

    /**
     * @var object
     * @desc The parent node.
     */
    protected $_parent;

    /**
     * @var \Sdds\Schema\Schema
     * @desc The schema object
     */
    protected $_schema;

    /**
     * @var \Sdds\Stream\Stream
     * @desc The stream object
     */
    protected $_stream;

    /**
     * @var \Sdds\Bitwise\Bitwise
     * @desc The bitwise object
     */
    protected $_bitwise;

    /**
     * @var object
     * @desc The registry object for the selectors.
     */
    protected $_registry;

    /**
     * @var string
     * @desc The path of current in the tree.
     */
    public $_path = '';

    /**
     * @var
     * @desc The source data, for input is byte_buffer, for output is a key-value array.
     */
    public $_source_data = '';

    /**
     * @var bool
     * @desc keep the flag if has read or write.
     */
    public $_done = false;

    /**
     * @var int
     * @desc Keep the index of repeat.
     */
    public $_index = 0;

    /**
     * @var array
     * @desc Keep the options of schema
     */
    public $_options = [];

    /**
     * @var
     * @desc keep the data length has read or written.
     */
    protected $_data_length = 0;

    /**
     * @var int
     * @desc The offset of the stream.
     */
    public $_offset = 0;

    /**
     * DataNode constructor.
     * @param $channel_name
     */
    public function __construct($channel_name){
        //make a backup copy.
        $this->attributes_keys = $this->attributes;
        $this->setChannelName($channel_name);
    }

    /**
     * @param $Stream
     * @param $Schema
     * @param $Bitwise
     * @desc Initialise the current node with the objects of Stream, Schema and Bitwise
     */
    public function init($Stream, $Schema, $Bitwise){
        $this->_stream = $Stream;
        $this->_schema = $Schema;
        $this->_bitwise = $Bitwise;
    }

    /**
     * @param $name
     * @return bool
     * @desc Check if the data type is a base type.
     */
    public function isBaseType($name){
        return $this->_stream->isBaseType($name);
    }

    /**
     * @return int
     * @desc Read the length of variable by calculation if needed.
     */
    public function getLength(){
        $length = $this->length;
        if($length < 0){
            $length += $this->_stream->size() - $this->_stream->offset();
        }
        $this->attributes['length'] = $length;
        return $this->attributes['length'];
    }

    /**
     * @return $this
     * @desc Make the function call before the operation of reading or writing.
     */
    public function triggerBeforeChange(){
        if(empty($this->before_change)){
            return $this;
        }
        $before_change = explode(',',$this->before_change);
        if(count($before_change) > 0){
            foreach($before_change as $method){
                $this->emitCall($method);
            }
        }
        return $this;
    }

    /**
     * @return $this
     * @desc Make the function call after the operation of reading or writing.
     */
    public function triggerAfterChange(){
        if(empty($this->after_change)){
            return $this;
        }
        $after_change = explode(',',$this->after_change);
        if(count($after_change) > 0){
            foreach($after_change as $method){
                $this->emitCall($method);
            }
        }
        return $this;
    }


    /**
     * @param $method
     * @return mixed|void
     * @desc call the method in called class or extension
     */
    public function emitCall($method){
        if(method_exists(get_called_class(),$method)){
            return $this->$method();
        }
        if($this->hasListener($method)){
            return $this->triggerEvent($method,$this,[]);
        }
        if(false===$this->isIgnoreErrors()) {
            throw RuntimeException::MethodNotExists($method);
        }
    }

    /**
     *
     * @return string
     * @desc Get the string format value of current node.
     * @important: This function only convert current node, not recursive!
     *
     */
    public function __toString()
    {
        if(!empty($this->format)){
        	$format = $this->format;
        	if('*' == $format[0]){
                $method = ltrim($format,'*');
                if($this->hasListener($method)){
                    return $this->triggerEvent($method,$this);
                }
                if(method_exists(get_called_class(),$method)){
                    return $this->$method();
                } /** else return the raw string */
        	}
            return sprintf($this->format,$this->value);
        }
        return (string)$this->value;
    }

    /**
     * @param $name
     * @return mixed
     * @desc The magic function
     */
    public function __get($name){

        if(!isset($this->attributes[$name])){
            if(isset($this->attributes_keys[$name])){
                return null;
            }
            if(property_exists($this,$name)){
                return $this->$name;
            }
            throw InvalidArgumentException::PropertyNotFound($name);
        }
        $value = $this->attributes[$name];
        if(!is_string($value)) {
            return $value;
        }
        if(empty($value)){
            return $value;
        }
        $selector_type = $value[0];
        return $this->getValueBySelector($selector_type,$value);

    }

    /**
     * @param $type
     * @param $selector
     * @return mixed
     * @desc Read the value by selector.
     */
    public function getValueBySelector($type,$selector){
        switch($type){
            case "@":
                return $this->getValueByPath($selector);
            case "#":
                return $this->getValueById($selector);
            case "$":
                return $this->getValueByIndex($selector);
            case "*":
                return $this->getValueByMethod($selector);
            default:
                return $selector;
        }
    }

    /**
     * @param $value
     * @return mixed
     * @desc Read the value by function call.
     */
    public function getValueByMethod($value){
        $method = ltrim($value,'*');
        if($this->hasListener($method)){
            return $this->triggerEvent($method,$this);
        }
        if(method_exists(get_called_class(),$method)){
            return $this->$method();
        }else{
            if(false===$this->isIgnoreErrors()) {
                throw RuntimeException::MethodNotExists($method);
            }
        }
        return null;
    }

    /**
     * @param $path
     * @return mixed
     * @desc Read the value by path
     */
    public function getValueByPath($path){

        if (!is_array($path)){
            $path = ltrim($path,'@');
            $path = explode('.',$path);
        }
        if ($this->name == $path[0]){
            if (count($path) > 1){
                array_shift($path);
                if(isset($this->_children[$path[0]])){
                    return $this->_children[$path[0]]->getValueByPath($path);
                }else{
                    if(false===$this->isIgnoreErrors()) {
                        throw RuntimeException::NodeNotfound($path);
                    }
                }
            }else{
                return $this->value;
            }
        }else{
            if(1 == $this->_level){
                if(false===$this->isIgnoreErrors()) {
                    throw RuntimeException::NodeNotfound(implode('.', $path));
                }
            }
            return $this->_parent->getValueByPath($path);
        }
        return null;
    }

    /**
     * @param $name
     * @param $value
     * @return $this
     * @desc The magic function.
     */
    public function __set($name,$value){

        if(property_exists($this,$name)){
            $this->$name = $value;
        }else{
            $this->attributes[$name] = $value;
        }
        return $this;
    }

    /**
     * @param $name
     * @return bool
     * @desc Check if the attribute is set.
     */
    public function __isset($name){
        if(property_exists($this,$name)){
            return ((isset($this->$name)&&(!empty($this->$name))));
        }
        return ((isset($this->attributes[$name])&&(!empty($this->attributes[$name]))));
    }

    /**
     * @param $name
     * @return $this
     * @desc Unset the attribute.
     */
    public function __unset($name)
    {
        if(property_exists($this,$name)){
            unset($this->$name);
        }else{
            unset($this->attributes[$name]);
        }
        return $this;
    }

    /**
     * @param $id
     * @return mixed
     * @desc Read a value to the variable array using id index.
     */
    public function getValueByID($id){
        $node_instance = $this->findById($id);
        return $node_instance->value;
    }

    /**
     * @param $name
     * @param $index
     * @return mixed
     * @desc Read a value by item name and id from the item share array.
     */
    public function getValueByIndex($name, $index = null){
        if(null === $index){
            $index = $this->_index;
        }
        $node_instance = $this->findByIndex($name,$index);
        return  $node_instance->value;
    }

    /**
     * @param $value
     * @param $format
     * @return string
     * @desc Format a key which using in One_Of node.
     */
    public function formatValue($value,$format){
        return sprintf($format,$value);
    }

    /**
     * @param $node
     * @desc Initialise the child node.
     */
    protected function initChild(&$node){
        //parent node
        $node->_parent = $this;
        //level
        $node->_level = $this->_level+1;
        //path
        $node->_path = $this->_path . '.' . $node->id;
        //Schema object
        $node->_schema = $this->_schema;
        //_index 
        if(null !== $this->_index){
            $node->_index = $this->_index;
        }
    }

    /**
     * @param $data_array
     * @desc Read all the data from schema json array.
     */
    public function initData($data_array){
        foreach($data_array as $key => $value){
            if(property_exists($this, $key)){
                $this->$key = $value;
            }else{
                $this->attributes[$key] = $value;
            }
        }
    }

    /**
     * destroy the children for save memory.
     * We call this function always from the top node.
     * So we need not call the parent.
     */
    public function destroy(){
        if(!empty($this->chillren)){
            foreach ($this->chillren as $val){
                $val->destroy();
                $val = null;
                unset($val);
            }
            if($this->_level>1){
                $this->_stream = null;
                unset($this->_stream);
                $this->_schema = null;
                unset($this->_schema);
                $this->_bitwise = null;
                unset($this->_bitwise);
            }
            $this->value =null;
            $this->_registry->clear();
        }
    }

    /**
     * @return int
     * @desc Get the total length include the children.
     */
    public function getChildLength(){
        $length = 0;
        if(count($this->_children) > 0){
            //Except the bit fields
            if($this->_child_type == NodeTypeConstants::OF_BIT_FIELDS){
                $length += $this->length;
                return $length;
            }
            //Sum the length of other children
            foreach($this->_children as $node){
                $length += $node->getChildLength();
            }
        }else{
            $length += $this->length;
        }
        return $length;
    }

    /**
     * @desc Set the property _offset value
     */
    public function writeOffset(){
        if(!empty($this->_stream)){
            $this->_offset = $this->_stream->offset();
        }else{
            $this->_offset = $this->_bitwise->offset();
        }
    }

    /**
     * Convert the tree object to associate array recursively.
     * @param $return_array
     * @return array
     */
    public function toArray(&$return_array){
        if(!empty($this->_children)){
            if(true == $this->repeat){
                $return_array['children']=$this->toChildrenArray();
            }else{
                foreach ($this->_children as $val){
                    $val->toArray($return_array);
                }
            }
        }
        if(null !== $this->value){
            if($this->_child_type != NodeTypeConstants::OF_BIT_FIELDS){
                if(!empty($this->name)){
                    $return_array[$this->name] = $this->value;
                }
            }

        }
    }

    /**
     * @return array
     * @desc Convert the children node to array
     */
    public function toChildrenArray(){
        $children_array = [];
        for($i=0,$j=count($this->_children);$i<$j;$i++){
            $this->_children[$i]->toArray($children_array[$i]);
        }
        return $children_array;
    }

    /**
     * Convert the tree object to associate array recursively.
     * @return array
     */
    public function toDebugArray(){
        $children = null;
        if(!empty($this->_children)){
            $children = [];
            foreach ($this->_children as $val){
                $children[] = $val->toDebugArray();
            }
        }
        $return_array = [
            'comment' => $this->comment,
            'id' => $this->id,
            'name' => $this->name,
            'value' => $this->value,
            '_path' => $this->_path
        ];
        if(!empty($children)){
            $return_array['children'] = $children;
        }
        return $return_array;
    }

    /**
     * @return mixed
     * @desc show the trace information for debug
     */
    public function showTrace(){
        if(empty($this->trace)){
            return ;
        }
        if(false === $this->_options['debug']){
            return ;
        }
        $trace_vars = explode(',',$this->trace);
        d("name: " .$this->name);
        foreach($trace_vars as $prop){
            $out_str = $this->$prop;
            if(is_array($out_str)){
                d($prop. ":  ");
                d($out_str);
            }
            d($prop . ":  " . $out_str);
        }
    }

    /**
     * @param $i
     * @param $length
     * @return bool
     * @desc The function only used by function dealRepeat()
     */
    protected function hasNext($i,$length){
    	$return = false;
        if(isset($this->until)){
            $method = $this->until;
            if($this->hasListener($method)){
                $return = $this->triggerEvent($method,$this);
            }
            if(method_exists($this,$method)){
                $return = $this->$method();
            }
            if (false === $return){
                throw RuntimeException::MethodNotExists($method);
            }
        }
        $check_length = $this->getLength();
        if(0 == ($this->count + $check_length)){
        	throw RuntimeException::missingRepeatCondition();
        }
        if(0 < $this->count){
        	$return = ($i < $this->count);
        }         
        if(0 < $check_length){            
            $return = ($length < $check_length);
        }
        return $return;
    }

    /**
     * if true === $this->ignore_errors will ignore errors.
     * @return bool|mixed
     */
    public function isIgnoreErrors(){
        if(!isset($this->ignore_errors)){
            return true;
        }
        return $this->ignore_errors;
    }

    /**
     * @param $manner
     * @param $param
     * @return mixed
     * @desc Find a node by the given manner and param.
     */
    public function findBy($manner,$param){
        switch ($manner){
            case SelectorConstants::BY_ID:
                return $this->findById($param);
            case SelectorConstants::BY_INDEX:
                return $this->findByIndex($param);
        }
        return null;
    }


    /**
     * @param $name
     * @param null $index
     * @return mixed
     * @desc Get the reference of the node instance from registry with index.
     */
    public function findByIndex($name,$index=null){
        $name = ltrim($name,'$');
        if(null === $index){
            $index = $this->_index;
        }
        try{
            return $this->_registry->getByIndex($name,$index);
        }catch(RuntimeException $e){
            if(false === $this->isIgnoreErrors()) {
                throw RuntimeException::nodeOfIndexNotFound($index);
            }
        }
        return null;
    }

    /**
     * @param $id
     * @return mixed
     * @desc Get the reference of the node instance from registry with id.
     */
    public function findById($id){
        $id = ltrim($id,'#');
        try{
            return $this->_registry->getById($id);
        }catch(RuntimeException $e){
            if(false === $this->isIgnoreErrors()) {
                throw RuntimeException::nodeNotFound($id);
            }
        }
        return null;
    }

    /**
     * @param $manner
     * @param $key
     * @param $instance
     * @return mixed
     * @desc Write a node reference with manner and key to the registry.
     */
    public function setBy($manner,$key,$instance){
        switch ($manner){
            case SelectorConstants::BY_ID:
                return $this->setById($key,$instance);
            case SelectorConstants::BY_INDEX:
                return $this->setByIndex($key,$instance);
        }
        return false;
    }

    /**
     * @param $id
     * @param $instance
     * @return mixed
     * @desc Write a node reference with id to the registry.
     */
    public function setById($id, $instance){
        if(empty($id)){
            return false;
        }
        $id = ltrim($id,'#');
        try{
            return $this->_registry->setById($id,$instance);
        }catch(RuntimeException $e){
            if(false === $this->isIgnoreErrors()) {
                throw RuntimeException::nodeOfIdHasSet($id);
            }
        }
        return true;
    }

    /**
     * @param $index
     * @param $instance
     * @param $name
     * @return mixed|bool
     * @desc Write a node reference with name and index to the Registry
     */
    public function setByIndex($index,$instance,$name = null){
        if(null == $name){
            $name = $this->name;
        }
        try{
            return $this->_registry->setByIndex($name,$index,$instance);
        }catch(RuntimeException $e){
            if(false === $this->isIgnoreErrors()) {
                throw RuntimeException::InstanceOfIndexHasSet($index);
            }
        }
        return true;
    }

}